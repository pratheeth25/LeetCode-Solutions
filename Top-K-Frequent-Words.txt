The most important thing I am learning from this question is that when you have #n elements, making a heap(priority_queue in c++) from n elements by pushing them one by one will be O(N*log(N)) and if we push them all at once then it would be O(N).
If this does'nt amaze you when you come to know this fact for the first time, then nothing will.

class Solution {
    public List<String> topKFrequent(String[] words, int k) {
        HashMap<String,Integer> map = new HashMap<>();
        for(String s:words){
            map.put(s,map.getOrDefault(s,0)+1);
        }
        List<String> ans = new ArrayList<>();
       PriorityQueue<Map.Entry<String, Integer>> pq =
              new PriorityQueue<>((a, b) -> {
        if (!a.getValue().equals(b.getValue())) {
            return Integer.compare(b.getValue(), a.getValue()); 
        }
        return a.getKey().compareTo(b.getKey()); 
    });

        pq.addAll(map.entrySet());
        for(int i=0;i<k;i++){
            ans.add(pq.poll().getKey());
        }
        return ans;
    }
}

The main important thing here is designing comparators which is essential 
Main comparators here are numerical for frequency mapping and alphabatical order which determines the answer
for example we have little and apple having same frequecny then apple should appear before little in ans arraylist
